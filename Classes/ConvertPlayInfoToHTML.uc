// NOTICE: This file was automatically generated by UCPP; do not edit this file manualy.
// #pragma ucpp include private.inc

/*******************************************************************************
    ConvertPlayInfoToHTML
<p>
    Convert the data in a PlayInfo record to HTML data. This is a more
    generalized implementation than given by the default WebAdmin.
    This also supports array variables (with some limitations). You can use the
    following array types: dynamic array, static array (string, int, float)
    Array types MUST use the CUSTOM render type (because of some bugs in the
    engine an other method isn't possible). The "extra" field in this case
    contains the same entries as in case of the TEXT render type.
</p>
<p>
    Written by: Michiel "El Muerte" Hendriks &lt;elmuerte@drunksnipers.com&gt;
</p>
<p>
    UsUnit Testing Framework -
    Copyright (C) 2005, Michiel "El Muerte" Hendriks
</p>

    This program is free software; you can redistribute and/or modify
    it under the terms of the Lesser Open Unreal Mod License.
    <!-- $Id: ConvertPlayInfoToHTML.uc,v 1.9 2006/01/07 17:00:35 elmuerte Exp $ -->
*******************************************************************************/
class ConvertPlayInfoToHTML extends Object;

// #ifdef HAS_PLAYINFO

/** includes files for various PlayInfo types */
var(Includes) string incEntry, incTypeCheck, incTypeText, incTypeSelect,
    incTypeSelectOption, incGroupBegin, incGroupEnd, incTypeText_NumEdit,
    incNumEditJS;

/** this array will contain the results, one line per entry */
var array<string> Results;

/** prefix for the replacement variables */
const PREFIX = "PI.";

/** The path to the include files. This will be set by ParsePlayInfo. */
var string IncludePath;

/** If true divide the entries in groups. Assumes the PI is sorted on groups */
var bool ShowGroups;

/** true if the JavaScript code for the special numedit was already included */
var protected bool incNumEditJS_included;

/** return false to not include a variable */
delegate bool ShowProperty(PlayInfo PI, int idx)
{
    return true;
}

/**
*/
function bool Query(WebRequest Request, WebResponse Response, string Path)
{
    local string inc, mime;
    switch (Mid(Request.URI, 1))
    {
        case "ConvertPlayInfoToHTML":
            inc = Request.GetVariable("inc", "");
            mime = Request.GetVariable("mime", "text/plain");
            if (inc != "")
            {
                Response.SendCachedFile(Path $ "/" $ inc, mime);
                return true;
            }
            return false;
    }
    return false;
}

/**
    parses the playinfo to HTML (stored in the Results array, will return true
    when succesfull. If WebRequest is provided all submitted variables in the
    request will also be stored (in case they where encountered). filter can
    be used to only show a certain group.
*/
function bool ParsePlayInfo(PlayInfo PI, WebResponse Response, string Path,
    optional WebRequest Request, optional string filter)
{
    local int i;
    local string NewVal, prevGroup;
    local bool unparsed;

    IncludePath = Path;
    Results.length = 0;

    incNumEditJS_included = false;

    for (i = 0; i < PI.Settings.length; i++)
    {
        if (ShowProperty(PI, i) && ((filter == "") || (PI.Settings[i].Grouping ~= filter)))
        {
            if (Request != none)
            {
// #ifdef HAS_PLAYINFO_UE25
                if (PI.Settings[i].ArrayDim >= 0)
                {
                    NewVal = ConstructArray(Request, PI, i);
                    PI.StoreSetting(i, NewVal);
                }
                else if (PI.Settings[i].bStruct)
                {
                    // compose struct !?
                }
                else {
// #endif
                    NewVal = class'UTServerAdmin'.static.HTMLDecode(Request.GetVariable(PI.Settings[i].SettingName, "")); //TODO: undefined
                    PI.StoreSetting(i, NewVal, PI.Settings[i].Data);
// #ifdef HAS_PLAYINFO_UE25
                }
            }
            if (PI.Settings[i].bStruct)
            {
                Warn("No yet implemented");
                continue; // not supported yet?
            }
// #endif

            unparsed = false;
            NewVal = "";
            switch (PI.Settings[i].RenderType)
            {
                case PIT_Check:
                    renderCheck(PI, i, Response, NewVal);
                    break;
                case PIT_Select:
                    renderSelect(PI, i, Response, NewVal);
                    break;
                case PIT_Text:
// #ifdef HAS_PLAYINFO_UE25
                    if (PI.Settings[i].ArrayDim >= 0)
                    {
                        Warn("Using an array property with render type TEXT causes issues, use type CUSTOM (reason: bugs in the engine).");
                    }
// #endif
                    renderText(PI, i, Response, NewVal);
                    break;
                case PIT_Custom:
                    if (renderCustom(PI, i, Response, NewVal)) break;
                default: unparsed = true; // unable to render this
            }
            if (unparsed) continue;

            if (ShowGroups && (prevGroup != PI.Settings[i].Grouping))
            {
                if (prevGroup != "") Results[Results.length] = Response.LoadParsedUHTM(IncludePath $ incGroupEnd);
                prevGroup = PI.Settings[i].Grouping;
                //Response.Subst(PREFIX$"Grouping", prevGroup); this is already set
                Results[Results.length] = Response.LoadParsedUHTM(IncludePath $ incGroupBegin);
            }

            Response.Subst(PREFIX$"InputField", NewVal);
            Results[Results.length] = Response.LoadParsedUHTM(IncludePath $ incEntry);
        }
    }
    if (ShowGroups && (prevGroup != ""))
    {
        Results[Results.length] = Response.LoadParsedUHTM(IncludePath $ incGroupEnd);
    }
    return true;
}

/** default substitutions */
function defaultSubst(PlayInfo PI, int idx, WebResponse Response)
{
    Response.Subst(PREFIX$"ID", repl(PI.Settings[idx].SettingName, ".", "_"));
    Response.Subst(PREFIX$"SettingName", PI.Settings[idx].SettingName);
    Response.Subst(PREFIX$"DisplayName", PI.Settings[idx].DisplayName);
    Response.Subst(PREFIX$"Description", PI.Settings[idx].Description);
    Response.Subst(PREFIX$"Data", PI.Settings[idx].Data);
    Response.Subst(PREFIX$"ExtraPriv", PI.Settings[idx].ExtraPriv);
    Response.Subst(PREFIX$"Grouping", PI.Settings[idx].Grouping);
    Response.Subst(PREFIX$"SecLevel", PI.Settings[idx].SecLevel);
    Response.Subst(PREFIX$"Value", PI.Settings[idx].Value);
    Response.Subst(PREFIX$"Weight", PI.Settings[idx].Weight);
    Response.Subst(PREFIX$"ClassFrom", PI.Settings[idx].ClassFrom);
}

/** called when the rendertype is CHECK */
function renderCheck(PlayInfo PI, int idx, WebResponse Response, out string result)
{
    // no such thing as bool arrays
    defaultSubst(PI, idx, Response);
    if (PI.Settings[idx].Value ~= "True") //TODO: use localized string?
        Response.Subst(PREFIX$"Checked", "checked=\"checked\"");
    else
        Response.Subst(PREFIX$"Checked", "");
    result = Response.LoadParsedUHTM(IncludePath $ incTypeCheck);
}

/** called when the rendertype is SELECT */
function renderSelect(PlayInfo PI, int idx, WebResponse Response, out string result)
{
    Warn("No yet implemented");
}

/**
    called when the rendertype is TEXT, but also in case of the following array
    types that had rendertype CUSTOM: dynamic arrays, static arrays of type: string,
    int, float.
*/
function renderText(PlayInfo PI, int idx, WebResponse Response, out string result)
{
    local array<string> entries, args;
    local int i;
    local string incfile;

    incfile = incTypeText;

    defaultSubst(PI, idx, Response);
    Response.Subst(PREFIX$"MaxLength", "2048"); // 2048 is sort of a engine limit
    Response.Subst(PREFIX$"Size", "80");

    Split(PI.Settings[idx].Data, ";", args);
    if (args.Length < 2) args.Length = 2; //set to minimum required number
    if (args[0] != "")
    {
        Response.Subst(PREFIX$"MaxLength", args[0]);
        Response.Subst(PREFIX$"Size", args[0]);
    }
    if (args[1] != "")
    {
        if (!incNumEditJS_included)
        {
            incNumEditJS_included = true;
            Results.insert(0, 1);
            Results[0] = Response.LoadParsedUHTM(IncludePath $ incNumEditJS);
        }
        incfile = incTypeText_NumEdit;
        Response.Subst(PREFIX$"Range", args[1]);
    }

// #ifdef HAS_PLAYINFO_UE25
    if (PI.Settings[idx].ArrayDim == -1)
    {
// #endif
        result $= Response.LoadParsedUHTM(IncludePath $ incfile);
        return;
// #ifdef HAS_PLAYINFO_UE25
    }
    else {
        SplitArray(PI.Settings[idx].Value, entries);
        if (PI.Settings[idx].ArrayDim > 0) entries.length = PI.Settings[idx].ArrayDim;
        else entries[entries.length] = ""; // to add an extra field for dynamic arrays
    }
    for (i = 0; i < entries.length; i++)
    {
        Response.Subst(PREFIX$"ID", repl(PI.Settings[idx].SettingName, ".", "_")$"_"$string(i));
        Response.Subst(PREFIX$"Value", entries[i]);
        result $= Response.LoadParsedUHTM(IncludePath $ incfile);
    }
// #endif
}

/**
    Handle elements that have rendertype CUSTOM.
*/
function bool renderCustom(PlayInfo PI, int idx, WebResponse Response, out string result)
{
// #ifdef HAS_PLAYINFO_UE25
    // test for known array types
    if (PI.Settings[idx].ThisProp.class == class'ArrayProperty'
        || (PI.Settings[idx].ArrayDim > 0 && (
                PI.Settings[idx].ThisProp.class == class'StrProperty'
                || PI.Settings[idx].ThisProp.class == class'IntProperty'
                || PI.Settings[idx].ThisProp.class == class'FloatProperty')
            )
        )
    {
        renderText(PI, idx, Response, result);
        return true;
    }
// #endif
    log("Called renderCustom for "$PI.Settings[idx].ThisProp, name);
    return false;
}

// #ifdef HAS_PLAYINFO_UE25
/**
    Split the UnrealEngine representation of an array back into an array
*/
static function SplitArray(string in, out array<string> res)
{
    local int i;
    local string tmp;
    local bool isStrings;

    isStrings = Left(in, 2) == "(\"";
    in = Mid(in, 1, len(in)-2); // strip ()
    i = InStr(in, ",");
    while (i > -1)
    {
        if (isStrings && InStr(Mid(in, 1), "\"") > i) // a comma inside a string
        {
            i++;
            while (Mid(in, i, 1) != "\"")
            {
                i++;
                if (Mid(in, i, 1) == "\\") i++; // escaped
            }
            i++; // to be on the , spot
        }
        tmp = Left(in, i);
        in = Mid(in, i+1);
        if (isStrings && Left(tmp, 1) == "\"") tmp = Mid(tmp, 1, len(tmp)-2); // strip "
        res[res.length] = tmp;
        i = InStr(in, ",");
    }
    if (isStrings && Left(in, 1) == "\"") in = Mid(in, 1, len(in)-2); // strip "
    res[res.length] = in;
}

/**
    Construct the string representation of an array.
*/
function string ConstructArray(WebRequest Request, PlayInfo PI, int idx)
{
    local string res, tmp;
    local int i, j;
    local bool noEmpty;
    noEmpty = true;

    if (PI.Settings[idx].ArrayDim == 0) j = Request.GetVariableCount(PI.Settings[idx].SettingName);
    else {
        j = PI.Settings[idx].ArrayDim;
        noEmpty = false;
    }

    for (i = j-1; i >= 0; i--)
    {
        tmp = class'UTServerAdmin'.static.HTMLDecode(Request.GetVariableNumber(PI.Settings[idx].SettingName, i, ""));
        tmp = repl(repl(tmp, "\\", "\\\\"), "\"", "\\\"");
        if (tmp == "")
        {
            if (noEmpty) continue;
        }
        else tmp = "\""$tmp$"\"";
        if (res != "") res = res$",";
        res $= tmp;
    }
    return "("$res$")";
}
// #endif

defaultProperties
{
    ShowGroups=true

    incEntry="usunit_pi_entry.inc"
    incTypeCheck="usunit_pi_typecheck.inc"
    incTypeText="usunit_pi_typetext.inc"
    incTypeText_NumEdit="usunit_pi_typetext_numedit.inc"
    incNumEditJS="usunit_numedit_js.inc"
    incGroupBegin="usunit_pi_groupbegin.inc"
    incGroupEnd="usunit_pi_groupend.inc"
}
// #endif
